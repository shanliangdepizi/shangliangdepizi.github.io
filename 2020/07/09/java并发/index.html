<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="java多线程," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="Java并发面试题基础进程与线程 定义  进程 程序的一次执行过程（进程从创建到消亡的过程） 系统运行程序的最小单元   线程 共享进程的堆与方法区 线程自有 程序计数器、虚拟机栈、本地方法栈">
<meta property="og:type" content="article">
<meta property="og:title" content="java并发">
<meta property="og:url" content="http://myblog.wuchao.space/2020/07/09/java%E5%B9%B6%E5%8F%91/index.html">
<meta property="og:site_name" content="工匠">
<meta property="og:description" content="Java并发面试题基础进程与线程 定义  进程 程序的一次执行过程（进程从创建到消亡的过程） 系统运行程序的最小单元   线程 共享进程的堆与方法区 线程自有 程序计数器、虚拟机栈、本地方法栈">
<meta property="article:published_time" content="2020-07-09T03:39:04.000Z">
<meta property="article:modified_time" content="2020-07-11T10:32:50.501Z">
<meta property="article:author" content="吴超">
<meta property="article:tag" content="java多线程">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://myblog.wuchao.space/2020/07/09/java并发/"/>





  <title> java并发 | 工匠 </title>
<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">工匠</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://myblog.wuchao.space/2020/07/09/java%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="吴超">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/wuchao.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="工匠">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                java并发
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-09T11:39:04+08:00">
                2020-07-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/07/09/java%E5%B9%B6%E5%8F%91/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/07/09/java并发/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h1><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><ol>
<li><p>定义</p>
<ul>
<li>进程<ul>
<li>程序的一次执行过程（进程从创建到消亡的过程）</li>
<li>系统运行程序的最小单元</li>
</ul>
</li>
<li>线程<ul>
<li>共享进程的堆与方法区</li>
<li>线程自有 程序计数器、虚拟机栈、本地方法栈<a id="more"></a>
</li>
</ul>
</li>
</ul>
</li>
<li><p>对比</p>
<ul>
<li><p>关系</p>
<ul>
<li>线程是进程划分的更小的运行单元</li>
<li>同一个进程的多个线程极有可能互相影响</li>
</ul>
</li>
<li><p>区别</p>
<ul>
<li>进程相互之间是独立的</li>
<li>线程互相之间极有可能互相影响</li>
</ul>
</li>
<li><p>优缺点</p>
<ul>
<li>线程执行开销小、不利于资源的管理与保护</li>
<li>进程执行开销大、可以有效的管理和保护资源</li>
</ul>
</li>
</ul>
</li>
<li><p>程序计数器（为什么私有）</p>
<ul>
<li>字节码解释器通过改变程序计数器来依次读取指令，实现代码的流程控制</li>
<li>在多线程情况下，程序计数器记录当前线程执行的位置，保证上下文切换的时候<br>当前线程还在之前执行的位置</li>
<li>作用：上下文切换之后，线程能恢复到正确的位置</li>
</ul>
</li>
<li><p>虚拟机栈与本地方法栈（为什么私有）</p>
<ul>
<li>虚拟机栈：Java方法在执行的时候，用来存储局部变量、操作数栈、常量池等  <pre><code>引用信息。入栈与出栈等同于方法的调用与执行结束</code></pre></li>
<li>本地方法栈：虚拟机栈是为虚拟机执行Java方法（字节码）服务，本地方法为虚拟<pre><code>机使用到的native服务</code></pre></li>
<li>为了保证现线程中的局部变量不被别的线程访问，所以都是线程私有的</li>
</ul>
</li>
<li><p>堆与方法区</p>
<ul>
<li>都是线程的共享资源</li>
<li>堆：内存中最大的区域，存储对象</li>
<li>方法区：存放已被加载的类信息、常量、静态变量、即时编译后的代码</li>
</ul>
</li>
</ol>
<h4 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h4><ul>
<li><p>并发</p>
<ul>
<li>同一时间段，多个任务都在执行（单位时间内不一定执行）</li>
</ul>
</li>
<li><p>并行</p>
<ul>
<li>单位时间内，多个任务执行</li>
</ul>
</li>
</ul>
<h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><ul>
<li><p>多线程的优点</p>
<ul>
<li><p>总体来说</p>
<ul>
<li>从计算机底层：多核CPU时代，多个线程可以同时运行，减少线程上下文切换的<pre><code>开销</code></pre></li>
<li>多线程并发编程利于开发高并发系统，可以大大提高系统整体的并发能力以及性<pre><code>能</code></pre></li>
</ul>
</li>
<li><p>计算机底层</p>
<ul>
<li>单核时代：多线程为了提高CPU 和O设备的综合利用率</li>
<li>多核时代：提高CPU利用率，多线程可以利用多个CPU核心</li>
</ul>
</li>
</ul>
</li>
<li><p>多线程的缺点</p>
<ul>
<li>内存泄漏</li>
<li>上下文切换</li>
<li>死锁</li>
<li>硬件与软件资源闲置的问题</li>
</ul>
</li>
</ul>
<h4 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h4><ul>
<li><p>6种状态</p>
<ul>
<li>NEW  初始状态，新建的线程</li>
<li>RUNNABLE 运行状态，操作系统中的就绪与运行两种状态统称为“运行中”</li>
<li>BLOCKING 阻塞状态，线程阻塞于锁</li>
<li>WAITE 等待状态，当前线程需要等待其他线程做出一些特定状态（通知或者中断）</li>
<li>TIME_WAITE  超时等待状态，在指定时间内自行返回</li>
<li>TERMINATED。终止状态 当前线程已经执行完毕</li>
</ul>
</li>
<li><p>图示：</p>
</li>
</ul>
<h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><ul>
<li>简介：CPU采取的策略是为每个线程分配时间片并轮询的方式。一个线程的时间片用完的时候，重新就绪让其他线程使用，这就是一次上下文切换</li>
<li>终结：当前任务执行完的时间片切换到另一个任务之前会保存自己的状态，以便下次切换回来能仔加载这个任务的状态</li>
<li>Linux Linux系统上下文切换和模式切换的时间消耗非常少</li>
</ul>
<h4 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h4><ul>
<li><p>死锁定义</p>
<ul>
<li>多个线程同时被阻塞，或者一个或者多个线程在等待某个资源释放，线程会被无限制的阻塞，程序无法终止</li>
</ul>
</li>
<li><p>产生死锁的四个条件</p>
<ul>
<li>互斥条件：某个资源只能被一个线程使用</li>
<li>请求和保存条件：一个线程因为请求某个资源阻塞时，对自己已获得的资源不释放</li>
<li>不剥夺条件：线程已获得的资源在未使用完成时，不能被其他的线程剥夺。只能自己使用完成后释放</li>
<li>循环等待条件：多个线程形成收尾相接的循环等待资源的情况</li>
</ul>
</li>
<li><p>避免死锁的方法</p>
<ul>
<li>破坏互斥条件：没得办法</li>
<li>破坏请求和保存条件：一次性申请所有的资源</li>
<li>破坏不剥夺条件：已获得部分资源的线程，在申请其他资源受阻的时候，主动释放以获取的资源</li>
<li>按序申请资源来预防，破坏循环等待的条件</li>
</ul>
</li>
</ul>
<h4 id="sleep-与wait"><a href="#sleep-与wait" class="headerlink" title="sleep()与wait()"></a>sleep()与wait()</h4><ul>
<li><p>区别</p>
<ul>
<li>sleep()方法不释放锁，wait()方法释放锁</li>
<li>sleep()方法用于线程等待，wait()方法主要用于线程间通信与交互</li>
<li>sleep()方法，方法执行完成之后，会主动唤醒；wait()方法方法执行完成，需要别的线程调用对象的notify()或者notifyAll()方法才能唤醒线程</li>
</ul>
</li>
<li><p>共同点</p>
<ul>
<li>都是使线程等待</li>
</ul>
</li>
</ul>
<h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><ul>
<li><p>synchronized关键字</p>
<ul>
<li><p>简介</p>
<ul>
<li>解决多个线程访问资源的同步性</li>
<li>JDK1.6版本进行优化：自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</li>
</ul>
</li>
<li><p>使用方式</p>
<ul>
<li><p>修饰实例方法：用于实例对象的加锁，进入同步代码前需要获取实例对象的锁</p>
</li>
<li><p>修饰静态方法</p>
<ul>
<li>用于当前类加锁，作用于该类的所有实例对象。</li>
<li>访问静态synchronized方法是获取类的锁，访问非synchronized方法或获取当前实例对象的锁，所以可以共存</li>
</ul>
</li>
<li><p>修饰语句块</p>
<ul>
<li>对给定对象加锁，进入同步代码代码块之前要获取给定对象的锁</li>
</ul>
</li>
</ul>
</li>
<li><p>底层原理</p>
<ul>
<li><p>同步代码块</p>
<ul>
<li>moniterenter指令是同步代码块开始的位置</li>
<li>moniterexit指令是同步代码块结束的位置</li>
</ul>
</li>
<li><p>修饰方法</p>
<ul>
<li>ACC_SYNCHRONIZED标识，指明该方法是一个同步方法</li>
<li>JVM通过ACC_SYNCHRONIZED判断某个方法是否是同步方法</li>
</ul>
</li>
</ul>
</li>
<li><p>优化</p>
<ul>
<li><p>JDK1.6之后对锁的优化，加入了如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。</p>
</li>
<li><p>锁的四种状态</p>
<ul>
<li>无锁状态</li>
<li>偏向锁状态</li>
<li>轻量级锁状态</li>
<li>重量级锁状态</li>
</ul>
</li>
<li><p>锁可以升级不能降级,目的是为了获取锁与释放锁的效率</p>
</li>
</ul>
</li>
<li><p>与ReentrantLock区别</p>
<ul>
<li><p>相同点：都是可重入锁</p>
<ul>
<li>可重入锁：自己可以重新获取自己的锁</li>
<li>这样能够减少死锁</li>
<li>举例：当一个线程获取某个对象的锁，此时该对象的锁还没有释放，当前线程还是可以再次获取该对象的锁。</li>
<li>线程每次获取锁，对象锁的计数器都会加1，只有对象锁的计数器为0，才能释放锁</li>
</ul>
</li>
<li><p>不同点</p>
<ul>
<li>子主题 1</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>volatile关键字</p>
<ul>
<li><p>内存模型</p>
<ul>
<li>后续画图</li>
</ul>
</li>
<li><p>与synchronized区别</p>
<ul>
<li><p>volatile关键字是线程同步的轻量级实现</p>
</li>
<li><p>性能</p>
<ul>
<li>volatile性能较好</li>
<li>synchronized关键字性能较低</li>
</ul>
</li>
<li><p>修饰对象</p>
<ul>
<li>volatile关键字修饰变量</li>
<li>synchronized关键字修饰实例方法、静态方法、代码块</li>
</ul>
</li>
<li><p>阻塞与否</p>
<ul>
<li>volatile关键字不阻塞</li>
<li>synchronized关键字可能阻塞</li>
</ul>
</li>
<li><p>原子性</p>
<ul>
<li>volatile关键字可以保证数据的可见性，但是不能保证原子性</li>
<li>synchronized关键字 即可保证数据的可见性，也可以保证数据的原子性</li>
</ul>
</li>
<li><p>目的</p>
<ul>
<li>volatile关键字 主要是解决变量在多个线程之间的可见性</li>
<li>synchronized关键字 主要解决多线程在访问资源时候的同步性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>ThreadLocal</p>
<ul>
<li><p>简介</p>
<ul>
<li>ThreadLocal类 主要是解决让每个线程绑定自己的值，用来存储每个线程自己的私有数据</li>
<li>每个线程在访问ThreadLocal变量的时候会创建一个本地副本，使用get()和set()方法获取与改变值</li>
</ul>
</li>
<li><p>代码示例</p>
<ul>
<li>另图</li>
</ul>
</li>
<li><p>原理分析</p>
<ul>
<li>底层是一个HashMap，ThreadLocalMap类型的变量。Thread.currentThread().getMap(Thread)访问ThreadLocalMap对象</li>
<li>ThreadLocalMap的数据结构：key为Thread对象，value为Object对象</li>
</ul>
</li>
<li><p>内存泄漏问题</p>
<ul>
<li><p>ThreadLocalMap 对key的引用是弱引用，而对value的引用是强引用，垃圾回收的时候会把key回收，但是value没有回收；会出现个key为null的value,会造成内存溢出</p>
</li>
<li><p>解决方法：ThreadLocalMap通过调用remove()方法清楚key为null的值</p>
</li>
<li><p>弱引用</p>
<ul>
<li>简介</li>
<li>与软引用的区别</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>线程池</p>
<ul>
<li><p>线程池的优点</p>
<ul>
<li>降低资源消耗： 重复利用已建的线程，降低线程创建于销毁的消耗</li>
<li>提高反应速度</li>
<li>提高线程的可管理性： 使用线程池可以对线程进行统一的分配、调优、监控</li>
</ul>
</li>
<li><p>Executor框架</p>
<ul>
<li><p>简介</p>
<ul>
<li>易于对线程进行管理，线程工厂、队列、饱和策略等。启动线程比Thread.start()更好，解决this逃避的问题</li>
<li>this逃避：构造函数返回之前，其他线程就拥有该对象的引用，调用未构造完成的对象，会出现错误</li>
</ul>
</li>
<li><p>框架结构</p>
<ul>
<li><p>任务（Runnable/Callable）</p>
<ul>
<li>需要实现Runnable接口或者Callable接口</li>
<li>这样可以被ThreadPoolExecutor或者ScheduledThreadPoolExecutor执行</li>
</ul>
</li>
<li><p>任务的执行（Executor）</p>
<ul>
<li><p>核心接口Executor接口 子接口ExecutorService接口，ThreadPoolExecutor和ScheduledThreadPoolExecutor实现上述接口</p>
</li>
<li><p>Executor接口</p>
<ul>
<li><p>ExecutorService接口</p>
<ul>
<li><p>AbstractExecutorService抽象类</p>
<ul>
<li>ThreadPoolExecutor实现类</li>
</ul>
</li>
<li><p>ScheduledExecutorService接口</p>
<ul>
<li>ScheduledThreadPoolExecutor实现类，继承extends ThreadPoolExecutor类</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>异步计算的结果（Future）</p>
<ul>
<li>Future接口以及实现类FutureTask都可以代表异步计算的结构</li>
<li>实现Runnable或者Callable接口的类提交给ThreadPoolExecutor或ScheduledThreadPoolExecutor执行。</li>
</ul>
</li>
</ul>
</li>
<li><p>使用示意图以及释义</p>
<ul>
<li><p>主线程首先创建实现Runnable/Callable接口的任务对象</p>
</li>
<li><p>把创建完成的对象交给ExecutorService执行</p>
<ul>
<li>ExecutorService.executor(Runnable command)</li>
<li>ExecutorService.submit(Runnable task)</li>
<li>ExecutorService.subnit(Callable<T> task)</T></li>
</ul>
</li>
<li><p>执行结束，返回一个Future接口的对象</p>
</li>
<li><p>最后，主线程执行FutureTask.get()方法等待任务执行完成。或者执行FutureTask.cancel(boolean myInterruptIfRunning)取消任务</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>几种比较</p>
<ul>
<li><p>Runnable接口与Callable接口区别</p>
<ul>
<li><p>返回和异常处理</p>
<ul>
<li>Runnable不会返回值也不会抛出异常</li>
<li>Callable 返回一个Future对象、也会抛出异常</li>
</ul>
</li>
<li><p>工具类Executors可以实现 Runnable接口与Callable接口的转换</p>
</li>
</ul>
</li>
<li><p>Excute()与submit()区别</p>
<ul>
<li>executor()方法用于没有返回值的任务，无法判断线程池是否执行完成</li>
<li>submit()方法 会返回一个Future类型对象（判断任务是否执行完成），Future对象的get()方法会阻塞线程，直到任务执行完成</li>
</ul>
</li>
<li><p>shutdown与shutdownNow</p>
<ul>
<li>shutdown 关闭线程，线程池的状态为SHUTDOWN，线程池不再接受新的任务，但是队列中的任务会继续执行完成</li>
<li>shutdownNow 关闭线程池，线程池的状态为STOP线程池会终止当前正在进行的任务，并停止处理队列的任务并返回正在等待执行任务的List</li>
</ul>
</li>
<li><p>isTerminated与isShutdown</p>
<ul>
<li>isShutdown 当调用shutdown()方法后返回为true</li>
<li>isTerminated 当调用shutdown()方法后，并且将所有提交的任务完成后返回true</li>
</ul>
</li>
</ul>
</li>
<li><p>创建方式</p>
<ul>
<li><p>通过构造方法创建： ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> blockingQueue, ThreadFactory factory)</Runnable></p>
</li>
<li><p>通过Executor的工具类Executors创建</p>
<ul>
<li><p>FixedThreadPool</p>
<ul>
<li><p>简介：创建一个可重用固定线程数量的线程池</p>
</li>
<li><p>执行任务的过程介绍</p>
<ul>
<li>如果当前运行的线程数小于coolPoolSize，如果有新任务，直接创建新线程执行</li>
<li>如果当前执行的任务数等于coolPoolSize,如果有新任务，将任务放入LinkedBlockingQueue队列中等待</li>
<li>线程池中的线程执行完手头的任务后，会循环反复从LinkedBlockingQueue中获取任务来执行</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>当线程池中的线程数达到corePoolSize后，新任务加入无界队列中等待，则maximum就是一个无效参数，在任务比较多的时候会出现OOM(OutOfMemory) 内存溢出</li>
</ul>
</li>
</ul>
</li>
<li><p>SingleThreadPool</p>
<ul>
<li><p>简介：只有一个线程的线程池</p>
</li>
<li><p>执行任务的过程</p>
<ul>
<li>如果当前没有运行的线程，则会新建线程来执行任务</li>
<li>如果线程池中有一个线程在运行，将新任务加入到LinkedBlockingQueue</li>
<li>线程执行完当前任务，会循环反复从BlockingQueue中获取新任务执行</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>无界队列的LinkedBlockingQueue 作为线程池的工作队列，会不断扩充队列，可能导致OOM 内存溢出</li>
</ul>
</li>
</ul>
</li>
<li><p>CacheThreadPool</p>
<ul>
<li><p>简介</p>
<ul>
<li>可根据实际情况调整线程数量的线程池</li>
<li>corePoolSize的值为0，maximum的值为Integer.MAX_VALUE</li>
</ul>
</li>
<li><p>执行任务的过程</p>
<ul>
<li>首先，执行SynchronousQueue.offer(Runnable task)提交任务到任务队列</li>
<li>如果当前maximum中有闲置线程正在执行SynchronousQueue.pool(keepAliveTime, TimeUnit.NANSECONDS)，则主线程执行offer与空置线程执行poll匹配。主线程将任务交给闲置线程执行</li>
<li>如果maximum是空的，或者maximum没有空的线程，此时CachedThreadPool会创建新的线程执行任务</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>允许创建的最大线程数为Integer.MAX_VALUE可能会创建大量线程，导致OOM</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>ThreadPoolExecutor 类分析</p>
<ul>
<li><p>构造方法中的参数</p>
<ul>
<li>corePoolSize:核心线程数  同时可运行的最小线程数</li>
<li>maximumPoolSize:最大线程数，当任务队列满的时候，可以运行线程的最大值</li>
<li>keepAliveTime:任务队列满的时候，等待的队列可存活的时间</li>
<li>TimeUnit:时间单位，用来设置存活的时间单位</li>
<li>BlockingQueue<Runnable>:存放任务的阻塞队列，当前任务打到corePoolSize的时候，任务存在在该队列</Runnable></li>
<li>ThreadFactory: 创建线程的工厂</li>
<li>Handle:饱和策略，当corePoolSize、BlockingQueue<Runnable>、maximum都满的时候执行怎么执行任务的策略</Runnable></li>
</ul>
</li>
<li><p>饱和策略</p>
<ul>
<li><p>定义：同时运行的线程数达到线程池的最大线程数(maximumPoolSize)，任务队列也满(BlockingQueue<Runnable>)，执行的策略</Runnable></p>
</li>
<li><p>策略</p>
<ul>
<li>ThreadPoolExecutor.AbortPolicy:拒绝策略，直接抛出RejectExecutionException来拒绝任务的执行</li>
<li>ThreadPoolExecutor.CallerRunsPolicy:用执行自己的线程来执行任务</li>
<li>ThreadPoolExecutor.DiscardPolicy:不执行任务，直接抛弃掉</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy:将最早的任务抛弃掉</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例：后续</p>
</li>
<li><p>原理分析</p>
<ul>
<li>corePoolSize已满，将任务放入BlockingQueue<Runnable></Runnable></li>
<li>BlockingQueue<Runnable>已满，maximum是否已满</Runnable></li>
<li>如果，maximum已满，执行设定的饱和策略。</li>
</ul>
</li>
<li><p>ScheduledThreadPoolExecutor详解</p>
<ul>
<li><p>简介</p>
<ul>
<li>ScheduledThreadPoolExecutor使用DelayQueue 封装的是一个PriorityQueue</li>
<li>PriorityQueue会对队列中的任务进行排序，执行所需时间短的会被先执行。ScheduledFutureTask的time变量小的会先执行</li>
<li>如果所需时间相同，则先提交的任务会被先执行（ScheduledFutureTask的squenceNumber变量小的会先执行）</li>
</ul>
</li>
<li><p>ScheduledThreadPoolExecutor与Timer的比较</p>
<ul>
<li><p>系统时钟</p>
<ul>
<li>Timer对系统时钟的变化敏感</li>
<li>ScheduledThreadPoolExecutor不是</li>
</ul>
</li>
<li><p>线程执行</p>
<ul>
<li>Timer只是一个执行线程，长时间的运行任务会延迟其他的任务</li>
<li>ScheduledThreadPoolExecuator可以配置任意数量的线程，通过ThreadFactory可以控制创建的线程</li>
</ul>
</li>
<li><p>异常情况</p>
<ul>
<li>TimerTask 中抛出的异常会杀死一个线程</li>
<li>ScheduledThreadPoolExecutor会抛出运行时异常，还可以去处理这个异常（重写afterExecute()方法ThreadPoolExecutor）。            抛出异常的任务将被取消，其他线程继续运行</li>
</ul>
</li>
</ul>
</li>
<li><p>运行机制</p>
<ul>
<li><p>ScheduledThreadPoolExecutor执行</p>
<ul>
<li>调用scheduleAtFixedRate()方法或者schduleWithFixedDelay()方法时，会向ScheduledThreadPoolExecutor的DelayQueue添加一个实现RunnableScheduledFuture接口的ScheduledFutureTask</li>
<li>线程池中的线程从DelayQueue中获取ScheduledFutureTask，然后执行任务</li>
</ul>
</li>
<li><p>对ThreadPoolExecutor做的修改</p>
<ul>
<li>使用DelayQueue作为任务队列</li>
<li>获取任务的方式不同</li>
<li>执行周期结束后，增加了额外的处理</li>
</ul>
</li>
</ul>
</li>
<li><p>执行周期任务的步骤</p>
<ul>
<li>线程一从DelayQueue中获取已到期的SchduledFutureTask(DelayQueue.take()).到期是指ScheduledFutureTask的time大于等于当前系统的时间</li>
<li>线程一执行这个ScheduledFutureTask</li>
<li>线程一修改ScheduledFutureTask的time变量为下次将要被执行的时间</li>
<li>线程一把这个修改time之后的ScheduledFutureTask放回DelayQueue中（DelayQueue.add()）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Atomic原子类</p>
<ul>
<li><p>简介：具有原子性或者原子类型的类</p>
</li>
<li><p>JUC 中的原子类</p>
<ul>
<li><p>基本数据类型</p>
<ul>
<li>AtomicInteger:整型原子类</li>
<li>AtomicLong:长整型原子类</li>
<li>AtomicBoolean:布尔类型的原子类</li>
</ul>
</li>
<li><p>数组类型</p>
<ul>
<li>AtomicIntegerArray:整型数组原子类</li>
<li>AtomicLongArray:长整型数组原子类</li>
<li>AtomicReferenceArray:引用类型数组原子类</li>
</ul>
</li>
<li><p>引用类型</p>
<ul>
<li><p>AtomicReference:引用类型原子类</p>
<ul>
<li>例子</li>
</ul>
</li>
<li><p>AtomicStampedReference:原子更新引用类型里的字段的原子类</p>
<ul>
<li>例子</li>
</ul>
</li>
<li><p>AtomicMarkableReference:原子更新有标位的原子类</p>
<ul>
<li>例子</li>
</ul>
</li>
</ul>
</li>
<li><p>对象的属性修改类型</p>
<ul>
<li><p>AtomicIntegerFieldUpdater:原子更新整型字段的更新器</p>
<ul>
<li>例子</li>
</ul>
</li>
<li><p>AtomicLongFieldUpdater:原子更新长整型字段的更新器</p>
<ul>
<li>例子</li>
</ul>
</li>
<li><p>AtomicStampedFieldUpdater:更新带有版本号的引用类型，可以解决原子的更新数据和数据的版本号，结合使用CAS进行原子更新时可能出现的ABA问题</p>
<ul>
<li>例子</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>AtomicInteger的使用</p>
<ul>
<li>public final int get() 获取当前值</li>
<li>public final int getAndSet(int newValue) 获取当前的值并替换成新值</li>
<li>public final int getAndIncrement() 获取当前的值并自增</li>
<li>public final int getAndDecrement()获取当前值并自减</li>
<li>public final int getAndAdd(int delta)获取当前值，并添加预期的值</li>
<li>Boolean compareAndSet(int expect, int update) 如果输入的值等于预期的值，则以原子的方式将该值设置成输入值（upfate）</li>
<li>public final void lazySet(int newValue)  最终设置成newValue，使用lazySet设置之后，会使线程在一段时间内还是会读到旧的直播</li>
</ul>
</li>
<li><p>AtomicInteger原理分析</p>
<ul>
<li>主要是利用CAS(compare and swap)+volatile关键字和native方法保证原子性。避免了synchronized的高开销</li>
<li>CAS原理：拿期望的值与原本的值作比较，如果相同则更新成最新的值</li>
</ul>
</li>
<li><p>AutomcticInteger优势</p>
<ul>
<li>1.多线程情况下不使用原子类，加锁保证线程安全</li>
<li>2.多线程情况下使用原子类，保证线程安全</li>
</ul>
</li>
</ul>
</li>
<li><p>AQS</p>
<ul>
<li><p>简介</p>
<ul>
<li>全称：AbstractQueuedSynchronizer</li>
<li>用来构建锁和同步器的框架</li>
</ul>
</li>
<li><p>原理</p>
<ul>
<li><p>概述</p>
<ul>
<li>核心思想：如果被请求的共享资源空闲，则将当前的请求资源的线程设置为有效的工作线程，并且将该共享资源设置成锁定状态；如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是利用CLH队列锁实现的，即将暂时获取不到锁的线程放入到队列中</li>
<li>CLH队列：全称 Craig,Landin,and Hegersten  是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH队列的一个结点（Node）来实现锁的分配</li>
<li>图示：后附</li>
</ul>
</li>
<li><p>对资源的共享方式</p>
<ul>
<li><p>Exclusive（独占）：只有一个线程可以执行。如ReentrantLock</p>
<ul>
<li>公平锁：根据线程的在队列中的先后顺序，先到者先拿到锁</li>
<li>非公平锁：当线程要获取锁的时候，无视先后顺序，直接去抢锁，谁抢到是谁的</li>
</ul>
</li>
<li><p>share(共享)：多个线程可以同时执行。</p>
</li>
</ul>
</li>
<li><p>AQS 自定义同步器的步骤</p>
<ul>
<li><p>继承AbstractQueuedSynchronizer，并重写方法（主要是对共享资源的state的获取与释放）</p>
</li>
<li><p>将AQS组合在自定义的同步组件的实现中，并调用其模板</p>
</li>
<li><p>需要重写的方法</p>
<ul>
<li>isHeldExclusively()该线程是否在独占资源，只有用到Condition才需要去实现它</li>
<li>tryAcquire(int) 独占方式，尝试获取资源</li>
<li>tryRelease(int) 独占方式，尝试释放资源</li>
<li>tryAcquireShared(int) 共享方式，尝试获取资源</li>
<li>tryReleaseShared(int) 共享方式，尝试释放资源</li>
</ul>
</li>
<li><p>自定义同步器的例子</p>
<ul>
<li><p>独占方式：以ReentrantLock为例</p>
<ul>
<li>共享资源的state初始状态为0，表示未锁定状态</li>
<li>A线程lock()时，会调用tryAcquire()独占该锁，则state+1</li>
<li>其他线程再tryAcquire()将会失败，直到A线程unlock()到state为0（释放锁），其他线程才有机会获取该锁</li>
<li>在释放锁之前，A线程可以重复获取此锁（state会累加），这就是可重入的概念。获取多少次就要释放多少次，直到state为0</li>
</ul>
</li>
<li><p>共享凡是：以CountDownLatch为例</p>
<ul>
<li>任务分成N个子线程去执行，state初始值为N（与子线程数量一致），这N个线程是并行执行的</li>
<li>每个子线程执行完成都会countDown()一次，state会CAS减1,。</li>
<li>等到所有子线程执行完成（也就是state=0）,会unpark()主线程，然后主线程就会从await()函数返回，继续后续动作</li>
</ul>
</li>
</ul>
</li>
<li><p>占用资源的方式</p>
<ul>
<li>独占方式</li>
<li>共享方式</li>
<li>可以同时实现以上两种：ReentrantReadWriteLock</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>组件</p>
<ul>
<li><p>Semaphore(信号量)：允许多个线程同时访问，可以指定多个线程同时访问某个资源</p>
</li>
<li><p>CountDownLatch(倒计时器)</p>
<ul>
<li><p>简介：是一个同步工具类，用来协调多个线程之间的同步，控制线程等待，知道倒计时结束，才继续执行</p>
</li>
<li><p>三种典型用法</p>
<ul>
<li><p>1.某个线程在开始运行之前，等待n个线程执行完毕。</p>
<ul>
<li>将CountDownLatch初始化为n，new CountDownLatch(n)，</li>
<li>每当一个任务执行完毕，CountDownLatch减1，countDownLatch.countDown()</li>
<li>当计数器为0，CountDownLatch上的await()的线程被唤醒。</li>
<li>示例：主线程需要等待其他组件加载完成，才执行</li>
</ul>
</li>
<li><p>2.实现多个线程执行任务的最大并行量。（某一时刻同时运行）</p>
<ul>
<li>初始化一个共享的CountDownLatch对象，将计数器初始化为1.new CountDownLatch(1)</li>
<li>多个线程开始执行任务之前，countDownLatch.await()</li>
<li>主线程调用countDown时，计数器为0，多个线程被唤醒</li>
</ul>
</li>
<li><p>死锁检测</p>
<ul>
<li>使用N个线程访问共享资源，在每次测试阶段的线程数目不同，尝试产生死锁</li>
</ul>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>CountDownLatch是一次性的，计数器的值只能在构造方法中初始化一次。</li>
<li>CountDownLatch使用完毕后，不能再次使用</li>
</ul>
</li>
<li><p>常见面试题</p>
<ul>
<li>解释一个CountDownLatch概念</li>
<li>CountDownLatch与CyclicBarrier的不同之处</li>
<li>给出一些CountDownLatch的使用例子</li>
<li>CountDownLatch的主要方法</li>
</ul>
</li>
</ul>
</li>
<li><p>CyclicBarrier(循环栅栏)：让一组线程到达一个屏障（同步点）时阻塞，直到最后一个线程到达屏障（同步点），屏障才会开门，所有被屏障拦截的线程才会后续操作。默认构造方法：CyclicBarrier(int parties)，parties：代表屏障拦截的线程数，每个线程调用await()方法告诉CyclicBarrier自己已到达屏障</p>
<ul>
<li><p>应用场景：用于多线程计算数据，最后合并计算结果的场景</p>
</li>
<li><p>使用示例</p>
</li>
<li><p>源码分析</p>
</li>
<li><p>CyclicBarrier与CountDownLatch的区别</p>
<ul>
<li><p>使用次数</p>
<ul>
<li>CyclicBarrier提供rest功能，可以重复使用</li>
<li>CountDownLatch只能使用一次</li>
</ul>
</li>
<li><p>重点</p>
<ul>
<li>CountDownLatch：一个或者多个线程等待，其他的线程完成执行后，可以终止或者等待</li>
<li>CyclicBarrier：多个线程中，任意一个线程执行完成之后，所有的线程等待</li>
</ul>
</li>
<li><p>功能</p>
<ul>
<li>CountDownLatch:是一个计数器，线程完成一个纪录一个</li>
<li>CyclicBarrier：是一个阀门。所以线程达到阈值，阀门才打开，然后继续执行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="必备技能"><a href="#必备技能" class="headerlink" title="必备技能"></a>必备技能</h2><h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><ul>
<li><p>ConcurrentHashMap:线程安全的HashMap</p>
<ul>
<li><p>读操作时候，基本不需要锁</p>
</li>
<li><p>写操作的时候，通过分段技术对操作的段加锁，不影响其他段的访问</p>
</li>
<li><p>具体实现方式（底层如何实现）</p>
<ul>
<li><p>JDK1.7</p>
<ul>
<li>分段实现segment，将HashMap分成很多段，按着段进行加锁</li>
<li>底层数据结构：是segment+数组+链表</li>
</ul>
</li>
<li><p>JDK1.8</p>
<ul>
<li>取消segment，使用synchronized和CAS来并发控制</li>
<li>底层数据结构：数组+链表+红黑树</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>CopyOnWriteArrayList:线程安全的List，读多写少的场合性能非常好，远远高于Vector</p>
<ul>
<li><p>简介：读取的数据的时候不加锁，写操作不会阻塞读操作，只是写入与写入之间阻塞</p>
</li>
<li><p>实现原理</p>
<ul>
<li>CopyOnWriteArrayList 在对数据进行修改时（可变操作 set 、add等），先将要修改的数据复制一份，将要修改的数据写入副本，写完之后再替换原来的数据，此时，写操作不影响读操作</li>
<li>CopyOnWrite:在计算机中，对内存进行修改，不在原有内存块中进行写操作，而是拷贝一份，在新内存中进行写操作，写完之后将原有内存指针指向新内存块，原来的内存会被回收</li>
</ul>
</li>
<li><p>源码分析</p>
<ul>
<li>读操作：将数组封装到volatile Object[] array中，然后从volatile Object[] array获取数据</li>
<li>写操作：对add操作加锁(ReentrantLocak),拷贝新数组，将先数组写入到原数组</li>
</ul>
</li>
</ul>
</li>
<li><p>ConcurrentLinkedQueue:高效的并发队列，使用链表实现。线程安全的LinkedList,非阻塞队列</p>
<ul>
<li>阻塞队列通过加锁实现，非阻塞队列通过CAS操作实现</li>
<li>通过链表作为数据结构，高并发下的性能最好的队列，通过CAS非阻塞算法实现线程安全</li>
</ul>
</li>
<li><p>BlockingQueue:这是一个接口，JDK内部通过链表和数组实现这个接口。阻塞队列，适用于作为数据共享的通道</p>
<ul>
<li><p>简介：应用于 生产者-消费者问题，当队列已满，生产者阻塞，直到队列有空位；当队列为空，消费者阻塞，直到队列中有数据（非空）</p>
</li>
<li><p>ArrayBlockingQueue</p>
<ul>
<li>BlockingQueue有界队列的实现类,底层是数组</li>
<li>容量不可变，并发控制采用可重入锁，无法保证线程访问队列的公平性</li>
</ul>
</li>
<li><p>LinkedBlockingQueue</p>
<ul>
<li>底层用单向链表实现的阻塞队列</li>
<li>可作为无界队列也可作为有界队列，无界时最大值为Integer.MAX_VALUE</li>
</ul>
</li>
<li><p>PriorityBlockingQueue</p>
<ul>
<li>支持优先级的无界队列，默认自然顺序排列，可用Comparator来指定排序规则</li>
<li>并发控制使用ReentrantLock</li>
<li>PriorityQueue的线程安全版本，不能有null值，插入队列的对象必须是可以比较大小的</li>
</ul>
</li>
</ul>
</li>
<li><p>ConcurrentSkipListMap:调表的实现，这是一个Map，使用跳表的数据结构进行快速查找</p>
<ul>
<li>跳表：针对单向链表，即将链表分段，高并发下，分段操作，提高性能</li>
<li>维护多个链表，链表是分层的</li>
<li>跳表中的所有元素是有序的，利用空间换时间的算法</li>
</ul>
</li>
</ul>
<h3 id="java线程池学习总结"><a href="#java线程池学习总结" class="headerlink" title="java线程池学习总结"></a>java线程池学习总结</h3><ul>
<li>上面已经写全</li>
</ul>
<h3 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h3><ul>
<li><p>定义</p>
<ul>
<li><p>悲观锁</p>
<ul>
<li>每次去拿数据的时候都认为别人会修改，每次拿数据都会上锁。</li>
<li>传统的关系型数据库就是这种锁机制，行锁、表锁、读锁、写锁等，java中的synchronized和ReentrantLock等独占资源的都是这种</li>
</ul>
</li>
<li><p>乐观锁</p>
<ul>
<li>每次去拿数据的时候都认为别人不会去修改数据，所以不会上锁，在更新的时候，判断写一次在此期间别人有没有去更新数据，可以使用CAS和版本号去实现</li>
<li>适用于多读的应用类型，可以调高吞吐量。数据库中的 write_conditon机制。java中java.util.concurrent.atomic包下面的原子变量类就是使用CAS实现的</li>
</ul>
</li>
</ul>
</li>
<li><p>使用场景</p>
<ul>
<li>乐观锁：适用于写比较少的情况下（多读场景）</li>
<li>悲观锁：适用于多写的场景</li>
</ul>
</li>
<li><p>乐观锁的实现方式</p>
<ul>
<li><p>版本号机制</p>
<ul>
<li><p>数据表中添加version字段，表示修改的次数</p>
<ul>
<li>修改时候，version会+1</li>
<li>更新的时候，读取数据的同时会读取版本号version值，提交更新的时候，读取的version值与数据库中的version一致才更新</li>
</ul>
</li>
<li><p>例子：账户信息表中有个version字段，当前值为1，当前用户的余额字段(balace)为$100</p>
<ul>
<li>操作员A此时读取（version=1），并从账号余额中扣除$50($100-$50)</li>
<li>在操作员A操作的过程中，操作员B也读取此用户信息（verison=1），并从账户扣除$20($100-20)</li>
<li>操作员A完成修改工作，将数据版本号+1（version=2），同时提交扣除账户后账户余额（balance=$50）到数据库。</li>
<li>操作员B完成修改工作，将版本号+1（version=2），同时提交余额（balance=$80）给数据库，比对数据库中的version值。此时数据库的version=2，操作员的提交被驳回。（乐观锁策略：提交的版本号要大于数据库中的版本号才能提交）</li>
</ul>
</li>
</ul>
</li>
<li><p>CAS算法</p>
<ul>
<li><p>简介</p>
<ul>
<li>compare and swap（比较和交换），无锁算法，非阻塞同步</li>
<li>不用锁的情况下，实现多线程之间的变量同步</li>
</ul>
</li>
<li><p>CAS算法核心</p>
<ul>
<li><p>三个操作数</p>
<ul>
<li>需要读取的内存值V</li>
<li>进行比较的值A</li>
<li>拟写入的值B</li>
</ul>
</li>
<li><p>算法</p>
<ul>
<li>当且仅当V的值等于A时，CAS通过原子方式用新值B替换V</li>
<li>否则不会执行任何操作，比较和替换是一个原子操作</li>
<li>一般情况下是一个自旋操作，会不断的重试</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>乐观锁的缺点</p>
<ul>
<li><p>ABA问题</p>
<ul>
<li>简介：变量V初次读取的时候等于A，准备赋值仍然是A。但是在初次读取数据与准备赋值的中间V的值可能被改成其他值，然后再改成A。但是CAS仍然认为他没有被修改过</li>
<li>解决办法：AtomicStampedReference类中的compareAndSet方法。首先要检查当前引用是否是预期引用，同时当前标志是否等于预期标志，全部相等才会用原子的方式更新值</li>
</ul>
</li>
<li><p>循环时间长开销大</p>
<ul>
<li>自旋CAS 如果不成功，一直再重试，这样会使得CPU的开销加大</li>
<li>JVM能支持处理器提供的pause指令</li>
</ul>
</li>
<li><p>只能保证一个共享变量的原子操作</p>
<ul>
<li>只会对当个共享变量有效</li>
<li>解决办法：利用AtomicReference类保证引用对象之间的原子性；可以将多个变量放在一个对象中进行CAS操作。</li>
</ul>
</li>
</ul>
</li>
<li><p>CAS与sychronized的使用场景</p>
<ul>
<li><p>CAS使用场景</p>
<ul>
<li>写比较少的场景，多读场景，冲突比较少</li>
<li>多于资源竞争少的情况，synchronized同步锁需要线程阻塞、唤醒、切换等操作，消耗CPU资源，而CAS基于硬件，能够获得更高的性能</li>
</ul>
</li>
<li><p>synchronized使用场景</p>
<ul>
<li>写比较多的场景 冲突比较多</li>
<li>对于资源竞争严重的，CAS自旋的几率大。浪费CPU资源</li>
</ul>
</li>
<li><p>synchronized底层实现</p>
<ul>
<li>依靠Lock-Free的队列</li>
<li>自旋后阻塞，竞争切换后继续竞争锁</li>
<li>稍微牺牲公平性，提高吞吐量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="JUC中的Atomic原子类总结"><a href="#JUC中的Atomic原子类总结" class="headerlink" title="JUC中的Atomic原子类总结"></a>JUC中的Atomic原子类总结</h3><ul>
<li>上面有详细介绍</li>
</ul>
<h3 id="AQS原理以及AQS同步组件"><a href="#AQS原理以及AQS同步组件" class="headerlink" title="AQS原理以及AQS同步组件"></a>AQS原理以及AQS同步组件</h3>
      
    </div>

    <div>
      
        
<div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="https://i.loli.net/2021/05/02/IAV8ecyQoqDBdNH.jpg" alt="吴超 wechat" style="width: 200px; max-width: 100%;"/>
    <div>subscribe to my blog by scanning my public wechat account</div>
</div>


      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag"># java多线程</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/07/09/docker/" rel="prev" title="docker">
                docker <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/wuchao.jpg"
               alt="吴超" />
          <p class="site-author-name" itemprop="name">吴超</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">67</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">34</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">30</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/shanliangdepizi/" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="wuchao.code@gmail.com" target="_blank" title="E-Mail">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  E-Mail
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://blog.zihang.xin" title="风的颜色" target="_blank">风的颜色</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java并发"><span class="nav-number">1.</span> <span class="nav-text">Java并发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题"><span class="nav-number">1.1.</span> <span class="nav-text">面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础"><span class="nav-number">1.1.1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#进程与线程"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">进程与线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并发与并行"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">并发与并行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多线程"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">多线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程的生命周期"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">线程的生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#上下文切换"><span class="nav-number">1.1.1.5.</span> <span class="nav-text">上下文切换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程死锁"><span class="nav-number">1.1.1.6.</span> <span class="nav-text">线程死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sleep-与wait"><span class="nav-number">1.1.1.7.</span> <span class="nav-text">sleep()与wait()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进阶"><span class="nav-number">1.1.2.</span> <span class="nav-text">进阶</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#必备技能"><span class="nav-number">1.2.</span> <span class="nav-text">必备技能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#并发容器"><span class="nav-number">1.2.1.</span> <span class="nav-text">并发容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java线程池学习总结"><span class="nav-number">1.2.2.</span> <span class="nav-text">java线程池学习总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#乐观锁与悲观锁"><span class="nav-number">1.2.3.</span> <span class="nav-text">乐观锁与悲观锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JUC中的Atomic原子类总结"><span class="nav-number">1.2.4.</span> <span class="nav-text">JUC中的Atomic原子类总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS原理以及AQS同步组件"><span class="nav-number">1.2.5.</span> <span class="nav-text">AQS原理以及AQS同步组件</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">吴超</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">
    NexT.Pisces
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  





  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="true"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  

    
      <script id="dsq-count-scr" src="https://wuchao.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://myblog.wuchao.space/2020/07/09/java%E5%B9%B6%E5%8F%91/';
          this.page.identifier = '2020/07/09/java并发/';
          this.page.title = 'java并发';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://wuchao.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  





  






  





  

  

  

  

</body>
</html>
